"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const process_1 = __importDefault(require("process"));
const allure_js_commons_1 = require("allure-js-commons");
const helpers_1 = require("./helpers");
class AllureReporter {
    constructor(options = { suiteTitle: true, detail: true }) {
        this.allureWriter = process_1.default.env.PW_ALLURE_POST_PROCESSOR_FOR_TEST
            ? new allure_js_commons_1.InMemoryAllureWriter()
            : undefined;
        this.allureGroupCache = new Map();
        this.allureTestCache = new Map();
        this.allureStepCache = new Map();
        this.hostname = process_1.default.env.ALLURE_HOST_NAME || os_1.default.hostname();
        this.options = options;
    }
    onBegin(config, suite) {
        this.config = config;
        this.suite = suite;
        this.resultsDir = allureReportFolder(this.options.outputFolder);
        this.allureRuntime = new allure_js_commons_1.AllureRuntime({
            resultsDir: this.resultsDir,
            writer: this.allureWriter,
        });
    }
    onTestBegin(test) {
        const suite = test.parent;
        const group = this.ensureAllureGroupCreated(suite);
        const allureTest = group.startTest(test.title);
        allureTest.addLabel(allure_js_commons_1.LabelName.LANGUAGE, "JavaScript");
        allureTest.addLabel(allure_js_commons_1.LabelName.FRAMEWORK, "Playwright");
        const [, projectSuiteTitle, fileSuiteTitle, ...suiteTitles] = suite.titlePath();
        if (projectSuiteTitle) {
            allureTest.addLabel(allure_js_commons_1.LabelName.PARENT_SUITE, projectSuiteTitle);
        }
        if (this.options.suiteTitle && fileSuiteTitle) {
            allureTest.addLabel(allure_js_commons_1.LabelName.SUITE, fileSuiteTitle);
        }
        if (suiteTitles.length > 0) {
            allureTest.addLabel(allure_js_commons_1.LabelName.SUB_SUITE, suiteTitles.join(" > "));
        }
        allureTest.historyId = test.titlePath().slice(1).join(" ");
        allureTest.fullName = test.title;
        this.allureTestCache.set(test, allureTest);
    }
    onStepBegin(test, _result, step) {
        const allureTest = this.allureTestCache.get(test);
        if (!allureTest) {
            return;
        }
        if (!this.options.detail && step.category !== "test.step") {
            return;
        }
        this.ensureAllureStepCreated(step, allureTest);
    }
    onStepEnd(_test, _result, step) {
        const allureStep = this.allureStepCache.get(step);
        if (!allureStep) {
            return;
        }
        if (!this.options.detail && step.category !== "test.step") {
            return;
        }
        allureStep.endStep();
        allureStep.status = step.error ? allure_js_commons_1.Status.FAILED : allure_js_commons_1.Status.PASSED;
    }
    onTestEnd(test, result) {
        var _a, _b, _c;
        const runtime = this.getAllureRuntime();
        const allureTest = this.allureTestCache.get(test);
        if (!allureTest) {
            return;
        }
        const thread = process_1.default.env.ALLURE_THREAD_NAME ||
            `${this.hostname}-${process_1.default.pid}-playwright-worker-${result.workerIndex}`;
        allureTest.addLabel(allure_js_commons_1.LabelName.HOST, this.hostname);
        allureTest.addLabel(allure_js_commons_1.LabelName.THREAD, thread);
        allureTest.status = statusToAllureStats(result.status, test.expectedStatus);
        if (result.error) {
            const message = result.error.message && stripAscii(result.error.message);
            let trace = result.error.stack && stripAscii(result.error.stack);
            if (trace && message && trace.startsWith(`Error: ${message}`)) {
                trace = trace.substr(message.length + "Error: ".length);
            }
            allureTest.statusDetails = {
                message,
                trace,
            };
        }
        for (const attachment of result.attachments) {
            if (!attachment.body && !attachment.path) {
                continue;
            }
            if (attachment.contentType === helpers_1.ALLURE_METADATA_CONTENT_TYPE) {
                if (!attachment.body) {
                    continue;
                }
                const metadata = JSON.parse(attachment.body.toString());
                (_a = metadata.links) === null || _a === void 0 ? void 0 : _a.forEach((val) => allureTest.addLink(val.url, val.name, val.type));
                (_b = metadata.labels) === null || _b === void 0 ? void 0 : _b.forEach((val) => allureTest.addLabel(val.name, val.value));
                (_c = metadata.parameter) === null || _c === void 0 ? void 0 : _c.forEach((val) => allureTest.addParameter(val.name, val.value, {
                    hidden: val.hidden,
                    excluded: val.excluded,
                }));
                if (metadata.description) {
                    allureTest.description = metadata.description;
                }
                continue;
            }
            let fileName;
            if (attachment.body) {
                fileName = runtime.writeAttachment(attachment.body, attachment.contentType);
            }
            else {
                if (!fs_1.default.existsSync(attachment.path)) {
                    continue;
                }
                fileName = runtime.writeAttachmentFromPath(attachment.path, attachment.contentType);
            }
            if (attachment.name.endsWith("-expected.png")) {
                allureTest.addAttachment("expected", attachment.contentType, fileName);
            }
            else if (attachment.name.endsWith("-actual.png")) {
                allureTest.addAttachment("actual", attachment.contentType, fileName);
            }
            else if (attachment.name.endsWith("-diff.png")) {
                allureTest.addAttachment("diff", attachment.contentType, fileName);
            }
            else {
                allureTest.addAttachment(attachment.name, attachment.contentType, fileName);
            }
            if (attachment.name === "diff" || attachment.name.endsWith("-diff.png")) {
                allureTest.addLabel("testType", "screenshotDiff");
            }
        }
        for (const stdout of result.stdout) {
            allureTest.addAttachment("stdout", "text/plain", runtime.writeAttachment(stdout, "text/plain"));
        }
        for (const stderr of result.stderr) {
            allureTest.addAttachment("stderr", "text/plain", runtime.writeAttachment(stderr, "text/plain"));
        }
        allureTest.endTest();
    }
    onEnd() {
        for (const group of this.allureGroupCache.values()) {
            group.endGroup();
        }
        if (process_1.default.env.PW_ALLURE_POST_PROCESSOR_FOR_TEST) {
            try {
                const writer = this.allureWriter;
                void writer;
                const postProcess = eval(process_1.default.env.PW_ALLURE_POST_PROCESSOR_FOR_TEST);
                console.log(JSON.stringify(postProcess(this.allureWriter)));
            }
            catch (e) {
                console.log(JSON.stringify({ error: e.stack || String(e) }));
            }
        }
    }
    getAllureRuntime() {
        if (!this.allureRuntime) {
            throw new Error("Unexpected state: `allureRuntime` is not initialized");
        }
        return this.allureRuntime;
    }
    ensureAllureGroupCreated(suite) {
        let group = this.allureGroupCache.get(suite);
        if (!group) {
            const parent = suite.parent
                ? this.ensureAllureGroupCreated(suite.parent)
                : this.getAllureRuntime();
            group = parent.startGroup(suite.title);
            this.allureGroupCache.set(suite, group);
        }
        return group;
    }
    ensureAllureStepCreated(step, allureTest) {
        let allureStep = this.allureStepCache.get(step);
        if (!allureStep) {
            const parent = step.parent
                ? this.ensureAllureStepCreated(step.parent, allureTest)
                : allureTest;
            allureStep = parent.startStep(step.title);
            this.allureStepCache.set(step, allureStep);
        }
        return allureStep;
    }
}
const statusToAllureStats = (status, expectedStatus) => {
    if (status === "skipped") {
        return allure_js_commons_1.Status.SKIPPED;
    }
    if (status === "timedOut") {
        return allure_js_commons_1.Status.BROKEN;
    }
    if (status === expectedStatus) {
        return allure_js_commons_1.Status.PASSED;
    }
    return allure_js_commons_1.Status.FAILED;
};
exports.default = AllureReporter;
const asciiRegex = new RegExp("[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))", "g");
const stripAscii = (str) => {
    return str.replace(asciiRegex, "");
};
const appendStep = (parent, step) => {
    const allureStep = parent.startStep(step.title, step.startTime.getTime());
    allureStep.endStep(step.startTime.getTime() + step.duration);
    allureStep.status = step.error ? allure_js_commons_1.Status.FAILED : allure_js_commons_1.Status.PASSED;
    for (const child of step.steps || []) {
        appendStep(allureStep, child);
    }
};
const allureReportFolder = (outputFolder) => {
    if (process_1.default.env.ALLURE_RESULTS_DIR) {
        return path_1.default.resolve(process_1.default.cwd(), process_1.default.env.ALLURE_RESULTS_DIR);
    }
    if (outputFolder) {
        return outputFolder;
    }
    return defaultReportFolder();
};
const defaultReportFolder = () => {
    return path_1.default.resolve(process_1.default.cwd(), "allure-results");
};
__exportStar(require("./helpers"), exports);
//# sourceMappingURL=index.js.map